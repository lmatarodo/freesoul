# 차선 라벨링 가이드라인

## 1. 기본 라벨링 원칙

### 1.1 차선만 라벨링하기
- **차선의 실제 경계만 라벨링**: 햇빛 반사, 그림자, 흰색 노이즈는 제외
- **연속성 유지**: 차선이 끊어진 부분도 이어지는 방향으로 예측하여 라벨링
- **정확한 경계**: 차선의 실제 가장자리를 정확히 표시

### 1.2 노이즈 제거 기준
- **햇빛 반사**: 차선 위의 밝은 반사는 제외
- **그림자**: 차선 주변의 어두운 영역은 제외  
- **흰색 노이즈**: 차선과 연결되지 않은 흰색 픽셀은 제외
- **도로 표시**: 차선이 아닌 다른 도로 표시는 제외

## 2. 라벨링 프로세스

### 2.1 전처리 단계
1. **Bird's Eye View 변환** 후 라벨링
2. **ROI 추출** (하단 300픽셀부터)
3. **256x256 크기로 리사이즈**

### 2.2 라벨링 단계
1. **차선 경계 확인**: 실제 차선의 가장자리 식별
2. **노이즈 식별**: 햇빛, 그림자, 기타 흰색 노이즈 구분
3. **바운딩 박스 그리기**: 차선만 포함하도록 정확히 박스 설정
4. **클래스 지정**: "left" 또는 "right"로 분류

## 3. 품질 관리

### 3.1 검증 기준
- [ ] 차선만 포함하고 노이즈는 제외
- [ ] 바운딩 박스가 차선 경계에 정확히 맞춤
- [ ] 좌우 차선이 올바르게 분류됨
- [ ] 연속된 차선이 끊어지지 않음

### 3.2 데이터 다양성
- **다양한 조명 조건**: 맑은 날, 흐린 날, 저녁 등
- **다양한 도로 상태**: 건조, 젖음, 눈 등
- **다양한 각도**: 직선, 곡선, 교차로 등

## 4. 후처리 검증

### 4.1 시각적 검증
```python
# 라벨링 결과 시각화
def visualize_labeling(image, boxes, classes):
    for i, box in enumerate(boxes):
        y1, x1, y2, x2 = box
        cv2.rectangle(image, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 2)
        cv2.putText(image, classes[i], (int(x1), int(y1)-10), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
    return image
```

### 4.2 통계적 검증
- 각 클래스별 바운딩 박스 수 확인
- 바운딩 박스 크기 분포 확인
- 이미지별 차선 검출률 확인

## 5. 실제 주행 환경 대응

### 5.1 노이즈 처리 강화
현재 코드의 `extract_lane_pixels` 함수가 이미 노이즈 제거를 수행:
- 이진화 임계값 (170) 사용
- 최소 픽셀 수 검증 (10개 이상)
- 직선 피팅으로 노이즈 제거

### 5.2 추가 개선 방안
- **모폴로지 연산**: 노이즈 제거 강화
- **연결 요소 분석**: 작은 노이즈 영역 제거
- **RANSAC 회귀**: 강건한 직선 피팅

## 6. 결론

깨끗한 라벨링은 YOLO 모델의 성능 향상에 직접적으로 기여합니다. 하지만 실제 환경의 다양성을 고려하여 다양한 조건에서의 데이터도 포함하는 것이 중요합니다. 